<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/icon16.png?v=2.0.0" type="image/png" sizes="16x16"><link rel="icon" href="/assets/icon32.png?v=2.0.0" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="O ever youthful O ever weeping">
<meta property="og:url" content="www.lutongtian.club/index.html">
<meta property="og:site_name" content="O ever youthful O ever weeping">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhen wu">
<meta name="twitter:card" content="summary"><meta name="keywords" content="zhen wu, O ever youthful O ever weeping"><meta name="description" content=""><title>O ever youthful O ever weeping</title><link ref="canonical" href="www.lutongtian.club/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">O ever youthful O ever weeping</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/01/18/Quartz/quartz-%E6%A1%86%E6%9E%B6/">quartz框架介绍</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-01-18</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-18</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Quartz框架">
          <a href="#Quartz框架" class="heading-link"><i class="fas fa-link"></i></a>Quartz框架</h1>
      
        <h3 id="简介：">
          <a href="#简介：" class="heading-link"><i class="fas fa-link"></i></a>简介：</h3>
      <p>Quartz是一个贼好用的定时任务框架。简介就这些吧，我觉着足够详细了。</p>
<p>现在公司的定时任务还是使用Spring自带的Scheduler，虽然一些任务运行时通过代码逻辑保证了分布式任务的数据一致性等问题，但是出现一些极端情况，比如程序崩溃，可能会导致一些数据的丢失问题或数据不完整等问题。</p>
<p>当然代码非常健壮，可能不会出啥问题，但是要投入更多的劳动力，肯定是不合适的。</p>

        <h3 id="直接上手：">
          <a href="#直接上手：" class="heading-link"><i class="fas fa-link"></i></a>直接上手：</h3>
      <p>pom依赖，主要就这俩：</p>
<figure class="highlight"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;quartz-jobs&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;quartz&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></div></figure>

<p>首先创建个类，这个类就是任务执行的类，加上Job接口，重写它的execute方法，就行了</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">// 具体业务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"Quartz已执行...."</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>然后创建一个Manager类，这个类就是任务管理类，主要是两项，一个Detail一个Trigger，Detail是调度业务逻辑，Trigger是调度触发器。</p>

        <h4 id="Detail是啥：">
          <a href="#Detail是啥：" class="heading-link"><i class="fas fa-link"></i></a>Detail是啥：</h4>
      <p>​    在JobDetail源码中可以看到这句话</p>
<img src="/2021/01/18/Quartz/quartz-%E6%A1%86%E6%9E%B6/image-20201202162352152.png" class title="Detail">

<p>大概意思就是Quartz会通过反射创建一个job实例，我们需要实现job接口，Quartz就会创建一个实例了，下边也说了一些Quartz应该定义的一些属性，比如组和实例名称之类的。</p>
<p>比较重要的是最后一段话，多个Trigger可以指向相同的job，但一个Trigger只能指向一个job。</p>

        <h4 id="Trigger是啥：">
          <a href="#Trigger是啥：" class="heading-link"><i class="fas fa-link"></i></a>Trigger是啥：</h4>
      <p>Trigger主要是写一些任务相关的触发机制，比如什么时候开始这个任务，什么时候关闭这个任务，每隔多久执行一次等等。ScheduleBuilder类中可以看到有四种触发方式。</p>
<img src="/2021/01/18/Quartz/quartz-%E6%A1%86%E6%9E%B6/image-20201202164717988.png" class title="Trigger">

<p>这个就是withSchedule里边的参数。</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        QuartzManager quartzManager = <span class="keyword">new</span> QuartzManager();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            quartzManager.schedulerFactory();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> JobDetail <span class="title">newJobDetail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JobDetail jobDetail = JobBuilder.newJob(HelloJob<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">                .withDescription("调用jobDetail")</span><br><span class="line">                .withIdentity(<span class="string">"定时任务A1"</span>,<span class="string">"定时任务A组"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> jobDetail;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Trigger <span class="title">newTrigger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Trigger trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                    .withDescription(<span class="string">"调用trigger"</span>)</span><br><span class="line">                    .startAt(<span class="keyword">new</span> Date())</span><br><span class="line">                    .withIdentity(<span class="string">"TriggerA1"</span>,<span class="string">"TriggerA组"</span>)</span><br><span class="line"><span class="comment">//                .withSchedule(SimpleScheduleBuilder.repeatSecondlyForTotalCount(10,5))</span></span><br><span class="line">                    <span class="comment">//用Cron，每2秒执行一次</span></span><br><span class="line">                    .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">"0/2  * * * * ?"</span>))</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="keyword">return</span> trigger;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedulerFactory</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">        SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line">        Scheduler scheduler = schedulerFactory.getScheduler();</span><br><span class="line">        <span class="comment">// 把Detail和Trigger加到Scheduler中</span></span><br><span class="line">        scheduler.scheduleJob(newJobDetail(),newTrigger());</span><br><span class="line">        System.out.println(<span class="string">"启动"</span>);</span><br><span class="line">        scheduler.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>直接main方法启动，可以看到打印日志已经成功了。</p>
<img src="/2021/01/18/Quartz/quartz-%E6%A1%86%E6%9E%B6/image-20201202165309798.png" class title="main-log"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/01/13/RocketMQ/RocketMQ-%E8%A7%92%E8%89%B2/">RocketMQ-角色</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-01-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-13</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="RocketMQ-角色">
          <a href="#RocketMQ-角色" class="heading-link"><i class="fas fa-link"></i></a>RocketMQ 角色</h1>
      
        <h3 id="NameServer：">
          <a href="#NameServer：" class="heading-link"><i class="fas fa-link"></i></a>NameServer：</h3>
      <p>搜集其他角色信息。</p>
<p>比如producer需要寻找一个topic在哪个broker下，直接向NameServer“询问”即可。</p>

        <h3 id="Broker：">
          <a href="#Broker：" class="heading-link"><i class="fas fa-link"></i></a>Broker：</h3>
      <ol>
<li><p>面向producer和consumer接收和发送消息</p>
</li>
<li><p>向NameServer提交自己的信息</p>
</li>
<li><p>是消息中间件的消息存储，转发服务器</p>
</li>
<li><p>每个Broker节点，在启动时，都会遍历NameServer列表，与每个NameServer建立长连接，注册自己的信息，之后定时上报</p>
</li>
</ol>

        <h4 id="集群：">
          <a href="#集群：" class="heading-link"><i class="fas fa-link"></i></a>集群：</h4>
      <ol>
<li>Broker高可用，可以配成Master/Slave结构，Master可写可读，Slave只可以读，Master将写入的数据同步给Slave。</li>
<li>一个Master可以对应多个Slave，但是一个Slave只能对应一个Master。</li>
<li>Master与Slave的对应关系通过制定相同的BrokerName，不同的BrokerId来定义BrokerId为0表示Master，非0表示Slave。</li>
<li>Master多机负载，可以部署多个broker</li>
<li>每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。</li>
</ol>

        <h3 id="Producer：">
          <a href="#Producer：" class="heading-link"><i class="fas fa-link"></i></a>Producer：</h3>
      <ol>
<li>消息的生产者</li>
<li>通过NameServer集群中的其中一个节点（随机选择）建立长连接，获得Topic的路由信息，包括Topic下面有哪些Queue，这些Queue分布在哪些Broker上等。</li>
</ol>

        <h3 id="Consumer：">
          <a href="#Consumer：" class="heading-link"><i class="fas fa-link"></i></a>Consumer：</h3>
      <ol>
<li>消息的消费者，通过NameSrever集群获得Topic路由信息，连接到对应的Broker上消费信息。</li>
<li>注意，由于Master和Slave都可以读取消息，因此Consumer会与Master与Slave都建立连接</li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/01/13/RocketMQ/RocketMQ-API/">RocketMQ-API</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-01-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-13</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="RocketMQ-API">
          <a href="#RocketMQ-API" class="heading-link"><i class="fas fa-link"></i></a>RocketMQ API</h1>
      
        <h3 id="producer：">
          <a href="#producer：" class="heading-link"><i class="fas fa-link"></i></a>producer：</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个生产者并启动</span></span><br><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"xxoo"</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">"xx.xx.xx.xx:9876"</span>);</span><br><span class="line">producer.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个消息体，两个参数，第一个是topic，第二个是写入的值</span></span><br><span class="line">Message msg = <span class="keyword">new</span> Message(<span class="string">"producer-test"</span>,<span class="string">"test1"</span>.getBytes());</span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">producer.send(msg);</span><br></pre></td></tr></table></div></figure>

<p>这里注意，我自己是阿里云服务器，用官网启动broker的步骤，在这是连不上broker，需要在broker的conf里加上以下配置：</p>
<figure class="highlight properties"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">brokerIP1</span>=<span class="string">xx.xx.xx.xx   # 这个是服务器的公网IP</span></span><br><span class="line"><span class="attr">autoCreateTopicEnable</span>=<span class="string">true # 配置自动创建topic</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="consumer：">
          <a href="#consumer：" class="heading-link"><i class="fas fa-link"></i></a>consumer：</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"xxoocsm"</span>);</span><br><span class="line">consumer.setNamesrvAddr(<span class="string">"101.200.84.242:9876"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个consumer只能关注一个topic</span></span><br><span class="line"><span class="comment">// topic 关注的消息地址</span></span><br><span class="line"><span class="comment">// 过滤器，用 “*” 的时候，不进行过滤</span></span><br><span class="line">consumer.subscribe(<span class="string">"producer-test"</span>,<span class="string">"*"</span>);</span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ConsumeConcurrentlyStatus有两个状态</span></span><br><span class="line">        <span class="comment">// CONSUME_SUCCESS 消费成功</span></span><br><span class="line">        <span class="comment">// RECONSUME_LATER 消费失败，MQ受到消费失败后，会再推送一遍，一般内部抛异常，会返回RECONSUME_LATER</span></span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br></pre></td></tr></table></div></figure>

<p>这时会打印出之前的produce的消息“test1“，再改变以下producer推送的消息，consumer会监听到新的消息。</p>
<p><img src="/13/RocketMQ/RocketMQ-API/D:%5Cstudy%5CMarkdown%5CRocketMQ%5Cimages%5Cimage-20201222170445661.png" alt="image-20201222170445661"></p>
<img src="/2021/01/13/RocketMQ/RocketMQ-API/image-20201222170445661.png" class title="pic">


        <h3 id="批量消息发送：">
          <a href="#批量消息发送：" class="heading-link"><i class="fas fa-link"></i></a>批量消息发送：</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Message msg1 = <span class="keyword">new</span> Message(<span class="string">"producer-test"</span>,<span class="string">"test1"</span>.getBytes());</span><br><span class="line">Message msg2= <span class="keyword">new</span> Message(<span class="string">"producer-test"</span>,<span class="string">"test2"</span>.getBytes());</span><br><span class="line">Message msg3= <span class="keyword">new</span> Message(<span class="string">"producer-test"</span>,<span class="string">"test3"</span>.getBytes());</span><br><span class="line">List&lt;Message&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(msg1);</span><br><span class="line">list.add(msg2);</span><br><span class="line">list.add(msg3);</span><br><span class="line">producer.send(list);</span><br></pre></td></tr></table></div></figure>

<p>放到list里，统一发送。减少网络交互。</p>

        <h3 id="异步消息：">
          <a href="#异步消息：" class="heading-link"><i class="fas fa-link"></i></a>异步消息：</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个消息体，两个参数，第一个是topic，第二个是写入的值</span></span><br><span class="line">Message msg = <span class="keyword">new</span> Message(<span class="string">"producer-test"</span>,<span class="string">"test-异步1"</span>.getBytes());</span><br><span class="line"><span class="comment">// 异步发送，无返回值</span></span><br><span class="line">producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        System.out.println(<span class="string">"消息发送成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">"消息发送失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/08/25/Mysql/Mysql-%E9%94%81%E6%9C%BA%E5%88%B6/">Mysql锁机制</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-08-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-08-25</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Mysql-锁机制">
          <a href="#Mysql-锁机制" class="heading-link"><i class="fas fa-link"></i></a>Mysql 锁机制</h1>
      
        <h2 id="mysql锁的基本介绍">
          <a href="#mysql锁的基本介绍" class="heading-link"><i class="fas fa-link"></i></a>mysql锁的基本介绍</h2>
      <p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p>
<p>表级锁：开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
<p>行级锁：开销大，加锁满，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<p>从以上特点可见，表锁更适合进行表查询，只有少量按索引条件更新数据的应用，行锁更适合按索引条件并发更新少量不同数据，同时又有并发查询的应用。</p>

        <h2 id="MyISAM表锁">
          <a href="#MyISAM表锁" class="heading-link"><i class="fas fa-link"></i></a>MyISAM表锁</h2>
      <p>两种模式：表共享读锁和表独占写锁。</p>
<p>对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求，对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作，MyISAM表的读与写操作之间是串行的。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/08/10/JVM/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/">JVM运行时数据区</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-08-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-08-10</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="JAVA运行时数据区">
          <a href="#JAVA运行时数据区" class="heading-link"><i class="fas fa-link"></i></a>JAVA运行时数据区</h1>
      
        <h2 id="运行时数据区">
          <a href="#运行时数据区" class="heading-link"><i class="fas fa-link"></i></a>运行时数据区</h2>
      <p>PC：程序计数器，存放下一条指令位置</p>
<p>​    虚拟机的运行，类似这样的循环：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(not end)&#123;</span><br><span class="line">	取PC中的位置，找到对应位置的指令；</span><br><span class="line">	执行该指令；</span><br><span class="line">	PC++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>JVM stacks：栈帧</p>
<p>Direct Memory ： JVM可以直接访问的内核控件的内存（OS管理的内存）</p>
<p>​    NIO，提高效率，实现zero copy</p>
<p>Method Area：方法区，各种class，常量池</p>
<p>Heap：堆</p>

        <h2 id="线程共享区">
          <a href="#线程共享区" class="heading-link"><i class="fas fa-link"></i></a>线程共享区</h2>
      <img src="/2020/08/10/JVM/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20200708175434393.png" class title="This is an example image">

<p>每个线程都是自己的PC，多线程切换，记录执行到哪个指令了</p>

        <h2 id="栈帧">
          <a href="#栈帧" class="heading-link"><i class="fas fa-link"></i></a>栈帧</h2>
      <p>Frame</p>
<ol>
<li>Local Variable Table ：局部变量表</li>
<li>Operand stack： 操作数栈</li>
<li>Dynamic Linking：指向常量池的指针</li>
<li>return address：返回值地址，a()调用了b(),b的返回值就存到这里</li>
</ol>
<p>一个方法对应一个栈帧，每个栈帧都记录了上面的4项。</p>

        <h2 id="常用指令">
          <a href="#常用指令" class="heading-link"><i class="fas fa-link"></i></a>常用指令</h2>
      <p>store： ()store_#xxx，等于压栈，把#xxx的数据读出来压栈，()内代表基本数据类型的缩写，比如int就是i。</p>
<p>load： ()load_#xxx，出栈，和store差不多</p>
<p>invoke</p>
<ol>
<li><p>invokeStatic：调静态方法</p>
<ol start="2">
<li>invokeVirtual：多态的方法</li>
<li>invokeInterface：调接口方法</li>
<li>invokeSpecial：可以直接定位，不需要多态的方法,private和构造方法。</li>
<li>InvokeDynamic：</li>
</ol>
</li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/08/08/JVM/JVM-%E8%B0%83%E4%BC%98/">JVM调优</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-08-08</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-08-08</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="JVM调优">
          <a href="#JVM调优" class="heading-link"><i class="fas fa-link"></i></a>JVM调优</h1>
      
        <h2 id="调优命令">
          <a href="#调优命令" class="heading-link"><i class="fas fa-link"></i></a>调优命令</h2>
      <p>HotSpot参数分类</p>
<p>标准：-开头，所有的HotSpot都支持</p>
<p>非标准：-X开头，特定版本HotSpot支持特定命令</p>
<p>不稳定：-XX开头，下个版本可能取消</p>

        <h3 id="区分概念：内存泄漏memory-leak，内存溢出outofmemory">
          <a href="#区分概念：内存泄漏memory-leak，内存溢出outofmemory" class="heading-link"><i class="fas fa-link"></i></a>区分概念：内存泄漏memory leak，内存溢出outofmemory</h3>
      <ol>
<li><p>java -XX:+PrintCommandLineFlags xxx</p>
<p>查看当前的虚拟机命令</p>
</li>
<li><p>java -Xmn10M -Xms40M -Xmx60M -XX:+PrintGC xxx</p>
<p>Xmn设置新生代大小 Xms设置堆的最小值，Xmx设置最大值，最好最大值和最小值一样，不要让堆有弹性空间，因为增长和收缩堆大小会消耗大量的计算机资源。</p>
</li>
<li><p>java -XX:+UseConcMarkSweepGC xxx</p>
<p>设置使用CMS</p>
</li>
</ol>
<p>PS日志格式</p>
<img src="/2020/08/08/JVM/JVM-%E8%B0%83%E4%BC%98/image-20200709184641655.png" class title="This is an example image">


        <h2 id="heap-dump解读：">
          <a href="#heap-dump解读：" class="heading-link"><i class="fas fa-link"></i></a>heap dump解读：</h2>
      <img src="/2020/08/08/JVM/JVM-%E8%B0%83%E4%BC%98/image-20200709185617606.png" class title="This is an example image">


        <h2 id="调优的基础概念">
          <a href="#调优的基础概念" class="heading-link"><i class="fas fa-link"></i></a>调优的基础概念</h2>
      <p>吞吐量：用户代码时间 / (用户代码时间 + 垃圾回收时间)</p>
<p>响应时间；STW越短，响应时间越好</p>
<p>吞吐量优先的：PS + PO，数据挖掘</p>
<p>响应时间优先：G1，网站 API</p>

        <h3 id="什么是调优">
          <a href="#什么是调优" class="heading-link"><i class="fas fa-link"></i></a>什么是调优</h3>
      <ol>
<li>根据需求进行JVM规划和预调优</li>
<li>优化运行JVM运行环境</li>
<li>解决JVM运行过程中出现的各种问题（OOM）</li>
</ol>

        <h3 id="调优，从规划开始">
          <a href="#调优，从规划开始" class="heading-link"><i class="fas fa-link"></i></a>调优，从规划开始</h3>
      <p>调优，从业务场景开始</p>
<p>无监控，不调优，监控是压力测试</p>
<p>步骤：</p>
<ol>
<li><p>赎续业务场景（没有最好的垃圾回收器，只有最合适的垃圾回收器）</p>
<pre><code>  1.    响应时间、停顿时间【CMS G1 ZGC】
           2.    吞吐量

3.    选择回收器组合

4.    计算内存需求

5.    设定年达大小

6.    设定日志参数</code></pre><p>记录GC日志文件</p>
<p>-Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log </p>
<p>-XX:+UseGCLogFileRotation </p>
<p>-XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M</p>
<p> -XX:+PrintGCDetails -XX:+PrintGCDateStamps </p>
<p>-XX:+PrintGCCause</p>
<p>或者每天产生一个日志文件</p>
</li>
<li><p>观察日志情况</p>
</li>
</ol>

        <h2 id="解决JVM运行中的问题">
          <a href="#解决JVM运行中的问题" class="heading-link"><i class="fas fa-link"></i></a>解决JVM运行中的问题</h2>
      <ol>
<li><p>java -Xms200M -Xmx200M -XX:+PrintGC com.mashibing.jvm.gc.T15_FullGC_Problem01</p>
</li>
<li><p>一般是运维团队首先受到报警信息（CPU Memory）</p>
</li>
<li><p>top命令观察到问题：内存不断增长 CPU占用率居高不下</p>
</li>
<li><p>top -Hp 观察进程中的线程，哪个线程CPU和内存占比高</p>
</li>
<li><p>jps定位具体java进程 jstack 定位线程状况，重点关注：WAITING BLOCKED eg. waiting on &lt;0x0000000088ca3310&gt; (a java.lang.Object) 假如有一个进程中100个线程，很多线程都在waiting on ，一定要找到是哪个线程持有这把锁 怎么找？搜索jstack dump的信息，找 ，看哪个线程持有这把锁RUNNABLE 作业：1：写一个死锁程序，用jstack观察 2 ：写一个程序，一个线程持有锁不释放，其他线程等待</p>
</li>
<li><p>为什么阿里规范里规定，线程的名称（尤其是线程池）都要写有意义的名称 怎么样自定义线程池里的线程名称？（自定义ThreadFactory）</p>
</li>
<li><p>jinfo pid</p>
</li>
<li><p>jstat -gc 动态观察gc情况 / 阅读GC日志发现频繁GC / arthas观察 / jconsole/jvisualVM/ Jprofiler（最好用） jstat -gc 4655 500 : 每个500个毫秒打印GC的情况 </p>
</li>
<li><p>jmap - histo 4655 | head -20，查找有多少对象产生</p>
</li>
<li><p>jmap -dump:format=b,file=xxx pid ：</p>
<p>线上系统，内存特别大，jmap执行期间会对进程产生很大影响，甚至卡顿（电商不适合）</p>
<p> 1：设定了参数HeapDump，OOM的时候会自动产生堆转储文件 </p>
<p>2：很多服务器备份（高可用），停掉这台服务器对其他服务器不影响 </p>
<p>3：在线定位(一般小点儿公司用不到)</p>
</li>
<li><p>java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError com.mashibing.jvm.gc.T15_FullGC_Problem01</p>
</li>
<li><p>使用MAT / jhat /jvisualvm 进行dump文件分析 <span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html" target="_blank" rel="noopener">https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> jhat -J-mx512M xxx.dump <span class="exturl"><a class="exturl__link" href="http://192.168.17.11:7000/" target="_blank" rel="noopener">http://192.168.17.11:7000</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 拉到最后：找到对应链接 可以使用OQL查找特定问题对象</p>
</li>
<li><p>找到代码的问题</p>
</li>
</ol>

        <h4 id="arthas在线排查工具">
          <a href="#arthas在线排查工具" class="heading-link"><i class="fas fa-link"></i></a>arthas在线排查工具</h4>
      <ul>
<li>为什么需要在线排查？ 在生产上我们经常会碰到一些不好排查的问题，例如线程安全问题，用最简单的threaddump或者heapdump不好查到问题原因。为了排查这些问题，有时我们会临时加一些日志，比如在一些关键的函数里打印出入参，然后重新打包发布，如果打了日志还是没找到问题，继续加日志，重新打包发布。对于上线流程复杂而且审核比较严的公司，从改代码到上线需要层层的流转，会大大影响问题排查的进度。</li>
<li>jvm观察jvm信息</li>
<li>thread定位线程问题</li>
<li>dashboard 观察系统情况</li>
<li>heapdump + jhat分析</li>
<li>jad反编译 动态代理生成类的问题定位 第三方的类（观察代码） 版本问题（确定自己最新提交的版本是不是被使用）</li>
<li>redefine 热替换 目前有些限制条件：只能改方法实现（方法已经运行完成），不能改方法名， 不能改属性 m() -&gt; mm()</li>
<li>sc - search class</li>
<li>watch - watch method</li>
<li>没有包含的功能：jmap</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/08/05/JVM/JVM-%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">JVM知识体系</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-08-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-08-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="JVM知识体系">
          <a href="#JVM知识体系" class="heading-link"><i class="fas fa-link"></i></a>JVM知识体系</h1>
      <img src="/2020/08/05/JVM/JVM-%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/image-20200707184416318.png" class title="This is an example image">


        <h2 id="类加载过程">
          <a href="#类加载过程" class="heading-link"><i class="fas fa-link"></i></a>类加载过程</h2>
      <img src="/2020/08/05/JVM/JVM-%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/image-20200707214902079.png" class title="This is an example image">

<ol>
<li>加载过程<ol>
<li>Loading：双亲委派</li>
<li>Linking<ol>
<li>Verification：校验，符合不符合class标准</li>
<li>Preparation：把class静态变量赋默认值</li>
<li>Resolution：Class常量值用的符号引用，转换成内存地址</li>
</ol>
</li>
<li>initializing：静态变量赋值为初始值。</li>
</ol>
</li>
</ol>

        <h3 id="类加载器">
          <a href="#类加载器" class="heading-link"><i class="fas fa-link"></i></a>类加载器</h3>
      <img src="/2020/08/05/JVM/JVM-%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/image-20200707215246317.png" class title="This is an example image">

<p>class漏到内存后，有两块内容，class内容放到内存，还有会生成一个class类对象，这个对象指向内存中的内容。</p>
<p>双亲委派机制：</p>
<p>​    如果有一个类A，需要漏到内存，会先从Custom加载器查询，如果没查询到，就委托给APP加载器，一直到Bootstrap，还没找到，就从Bootstrap加载器开始实际加载类A，如果Bootstrap发现类A不在自己加载的职责范围内，就委托给EXT加载器，一直到Custom加载器。</p>
<p>每个加载器都有自己的缓存，记录自己加载的类。</p>
<p>为什么要做双亲委派，不直接都漏到同一个内存？</p>
<p>​    主要是为了安全，比如自定义实现一个java.lang.String类，会覆盖掉原java的类库</p>

        <h2 id="自定义类加载器">
          <a href="#自定义类加载器" class="heading-link"><i class="fas fa-link"></i></a>自定义类加载器</h2>
      <p>使用ClassLoadr的loadClass方法，读取自己写的class。</p>
<p>继承ClassLoader类，重写findClass方法，把class文件转成二进制流，再调用defineClass，生成class对象</p>

        <h2 id="懒加载">
          <a href="#懒加载" class="heading-link"><i class="fas fa-link"></i></a>懒加载</h2>
      <p>JVM规范并没有规定什么时候加载类</p>
<p>但是严格规定了什么时候必须初始化</p>

        <h2 id="解释器">
          <a href="#解释器" class="heading-link"><i class="fas fa-link"></i></a>解释器</h2>
      <img src="/2020/08/05/JVM/JVM-%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/image-20200707231850298.png" class title="This is an example image"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/08/01/JVM/JVM-GC-%E8%B0%83%E4%BC%98/">JVM-GC调优</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-08-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-08-01</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="JVM-GC-Collector">
          <a href="#JVM-GC-Collector" class="heading-link"><i class="fas fa-link"></i></a>JVM-GC Collector</h1>
      
        <h2 id="垃圾">
          <a href="#垃圾" class="heading-link"><i class="fas fa-link"></i></a>垃圾</h2>
      <p>没有引用指向的，都是垃圾。</p>

        <h3 id="java垃圾处理">
          <a href="#java垃圾处理" class="heading-link"><i class="fas fa-link"></i></a>java垃圾处理</h3>
      <p>GC处理垃圾</p>
<p>开发效率高，执行效率低</p>

        <h3 id="Root-Searching-根可达算法">
          <a href="#Root-Searching-根可达算法" class="heading-link"><i class="fas fa-link"></i></a>Root  Searching 根可达算法</h3>
      <img src="/2020/08/01/JVM/JVM-GC-%E8%B0%83%E4%BC%98/image-20200709122136643.png" class title="This is an example image">


        <h3 id="GC-Algorithms-引用计数">
          <a href="#GC-Algorithms-引用计数" class="heading-link"><i class="fas fa-link"></i></a>GC Algorithms 引用计数</h3>
      <p>Mark-Sweep（标记清除）：把没用的标记出来，清掉。</p>
<p>​        存活的对象比较多的情况下，效率比较高。</p>
<p>​        执行效率低，需要两遍扫描，容易产生碎片。</p>
<p>Copying（拷贝）：把内存一分为二，把没用的和有用的分开</p>
<p>​        适用于存活的对象较少的情况，只扫描一次，效率高，没有碎片。</p>
<p>​        空间浪费，移动复制对象，需要调整对象引用</p>
<p>​        适合eden区</p>
<p>Mark——Compact（标记压缩）：把存活对象整理到一个角落或者控件，剩下的全部清掉。</p>
<p>​        不会产生碎片，方便对象分配，不会产生内存减半。</p>
<p>​        扫描两次，需要移动对象，效率偏低。</p>

        <h2 id="JVM内存分代模型">
          <a href="#JVM内存分代模型" class="heading-link"><i class="fas fa-link"></i></a>JVM内存分代模型</h2>
      <p>部分垃圾回收期使用的模型</p>
<p>字符串常量自1.8后移动到堆里</p>
<p>Metaspce是堆之外的空间，受限于物理内存</p>

        <h3 id="新生代-老年代-元数据区Metaspace">
          <a href="#新生代-老年代-元数据区Metaspace" class="heading-link"><i class="fas fa-link"></i></a>新生代+老年代+元数据区Metaspace</h3>
      <p>新生代：Eden+2个suvivor区</p>
<pre><code>1.    YGC回收之后，大多数对象会被回收，活着的进入S0

   2.    再次YGC，活着的对象eden+s0 -&gt; s1
            3.    再次YGC,eden+ s1 -&gt; s0
         4.    年龄足够 --老年代（15，CMS 6）
            5.    s区装不下 --老年代</code></pre><p>老年代：顽固分子  ，老年代满了FGC</p>
<p>GC</p>

        <h2 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>
      <img src="/2020/08/01/JVM/JVM-GC-%E8%B0%83%E4%BC%98/image-20200709140252110.png" class title="This is an example image">


        <h2 id="垃圾回收器">
          <a href="#垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a>垃圾回收器</h2>
      <img src="/2020/08/01/JVM/JVM-GC-%E8%B0%83%E4%BC%98/image-20200709160805568.png" class title="This is an example image">

<ol>
<li><p>Serial：stop-the-world，停止所有线程，但是要在save point（安全点）进行停止，进行垃圾回收，单CPU效率最高，适合内存小的时候用。</p>
</li>
<li><p>Parallel Scavenge：默认JVM使用的就是PS+PO，区别和Serial就是并行</p>
</li>
<li><p>Parallel old：老年代使用的，是用Compact垃圾回收算法。</p>
</li>
<li><p>ParNew：是Parallel的变种，做了支持CMS的增强</p>
</li>
<li><p>CMS：</p>
<img src="/2020/08/01/JVM/JVM-GC-%E8%B0%83%E4%BC%98/image-20200709163326430.png" class title="This is an example image">

<p>分为4个阶段</p>
<p>初始标记：是标记根对象，其他的先不标记</p>
<p>并发标记：是同时允许程序运行，并启动多线程同时进行标记，主要是这部分占用时间长</p>
<p>重新标记：是把并发标记中过程中，诞生出的新的垃圾，做重新标记，这块就是STW了。</p>
<p>并发清理：进行并发清理。</p>
<p>CMS的缺点：会产生内存碎片，当多次CMS后，新生代往老年代移动的时候，如果发现老年代里都是碎片，没地了。就会触发单线程的Serial，进行清理，速度非常慢</p>
<p>解决方案：</p>
<pre><code>1.    调整CMS发生FGC的内存阈值，默认是92%，改成50-80%。看情况。</code></pre></li>
</ol>

        <h4 id="垃圾收集器跟内存大小的关系">
          <a href="#垃圾收集器跟内存大小的关系" class="heading-link"><i class="fas fa-link"></i></a>垃圾收集器跟内存大小的关系</h4>
      <p>serial  几十兆</p>
<p>PS 上百兆-几G</p>
<p>CMS-20G</p>
<p>G1-上百G</p>
<p>ZGC- 4T - 16T</p>

        <h2 id="并发阶段的算法">
          <a href="#并发阶段的算法" class="heading-link"><i class="fas fa-link"></i></a>并发阶段的算法</h2>
      
        <h3 id="三色标记算法-CMS-incrementtal-Update">
          <a href="#三色标记算法-CMS-incrementtal-Update" class="heading-link"><i class="fas fa-link"></i></a>三色标记算法-CMS + incrementtal Update</h3>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/08/01/JVM/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">JAVA内存模型</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-08-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-08-01</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="JAVA内存模型">
          <a href="#JAVA内存模型" class="heading-link"><i class="fas fa-link"></i></a>JAVA内存模型</h1>
      
        <h2 id="硬件层并发优化基础">
          <a href="#硬件层并发优化基础" class="heading-link"><i class="fas fa-link"></i></a>硬件层并发优化基础</h2>
      
        <h3 id="存储器的层次结构">
          <a href="#存储器的层次结构" class="heading-link"><i class="fas fa-link"></i></a>存储器的层次结构</h3>
      <img src="/2020/08/01/JVM/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20200707234920046.png" class title="存储器的层次结构">


        <h3 id="cache-line-padding">
          <a href="#cache-line-padding" class="heading-link"><i class="fas fa-link"></i></a>cache line padding</h3>
      <p>利用MESI（缓存一致性协议），对齐cpu缓存头，不被其他数据干扰，提高效率，在变量前后增加 public long p1,p2,p3…..p7</p>
<img src="/2020/08/01/JVM/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20200708001829005.png" class title="缓存一致性">


        <h2 id="CPU乱序">
          <a href="#CPU乱序" class="heading-link"><i class="fas fa-link"></i></a>CPU乱序</h2>
      <p>CPU为了提高执行执行效率，会在一条执行执行过程中，去同时执行另一条指令，前提是，两条指令没依赖关系。</p>
<p>如何保证不乱序：volatile</p>
<p>volatile:</p>
<pre><code>1.    有序性保障
            1.    intel lock ，汇编指令
         2.    CPU内存屏障
             1.    sfence：存屏障，在sfence指令前的写操作必须在sfence写操作后的操作前完成。
             2.    lfence：读屏障，同sfence。
             3.    mfence：读写屏障，同sfence。</code></pre>
        <h2 id="volatile的实现细节">
          <a href="#volatile的实现细节" class="heading-link"><i class="fas fa-link"></i></a>volatile的实现细节</h2>
      <p>字节码层面：ACC_VOLATILE</p>
<p>JVM层面：volatile内存区的读写都加屏障</p>
<p>OS和硬件层面：lock 指令</p>

        <h2 id="synchronize的实现细节">
          <a href="#synchronize的实现细节" class="heading-link"><i class="fas fa-link"></i></a>synchronize的实现细节</h2>
      <p>字节码层面：加入monitorenter monitorexit  </p>
<p>JVM层面：C   C++调用了操作系统提供的同步机制</p>
<p>OS和硬件层面：lock 指令</p>

        <h2 id="java并发内存模型">
          <a href="#java并发内存模型" class="heading-link"><i class="fas fa-link"></i></a>java并发内存模型</h2>
      


        <h2 id="对象的创建过程">
          <a href="#对象的创建过程" class="heading-link"><i class="fas fa-link"></i></a>对象的创建过程</h2>
      <ol>
<li>class loading</li>
<li>class linking（verif，prepar，resolu）</li>
<li>init   静态变量设初始值，同时执行静态语句块</li>
<li>申请对象内存</li>
<li>成员变量赋默认值</li>
<li>调用构造方法<ol>
<li>成员变量顺序赋初始值</li>
<li>执行构造方法语句</li>
</ol>
</li>
</ol>

        <h3 id="对象在内存中的布局">
          <a href="#对象在内存中的布局" class="heading-link"><i class="fas fa-link"></i></a>对象在内存中的布局</h3>
      <p>普通对象：</p>
<pre><code>1.    对象头：markword 8，标识一些对象的状态

   2.    ClassPointer指针：指向XX.class，为4字节，如果不开启jvm的UseCompreessedClassointers为8字节
            3.    实例数据：成员变量，引用类型，开启Oops为4字节，不开启为8字节
         4.    Padding对齐，8的倍数。</code></pre><p>数组对象：</p>
<p>​    比普通对象多个数组长度（4字节）</p>

        <h3 id="对象头具体包括什么">
          <a href="#对象头具体包括什么" class="heading-link"><i class="fas fa-link"></i></a>对象头具体包括什么</h3>
      <p>markword 8个字节 64位</p>
<p>有1位代表是不是偏向锁</p>
<p>有两位代表对象有没有被锁定（sync）</p>
<p>4位代表GC分代年龄</p>
<p>其他的是根据锁的不同，存储不同的东西。</p>

        <h3 id="对象定位">
          <a href="#对象定位" class="heading-link"><i class="fas fa-link"></i></a>对象定位</h3>
      <ol>
<li>句柄池</li>
<li>直接指针 ClassPointer</li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/07/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%8E%9F%E7%90%86/">区块链-原理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-07-29</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-07-29</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="区块链-比特币、挖矿、抄币的原理">
          <a href="#区块链-比特币、挖矿、抄币的原理" class="heading-link"><i class="fas fa-link"></i></a>区块链-比特币、挖矿、抄币的原理</h1>
      <p>去中心化的、匿名的、安全的、不可篡改的、开放的下一代互联网</p>

        <h2 id="区块链中的三权分立">
          <a href="#区块链中的三权分立" class="heading-link"><i class="fas fa-link"></i></a>区块链中的三权分立</h2>
      <ol>
<li>币圈</li>
<li>链圈</li>
<li>矿圈</li>
</ol>

        <h2 id="什么是区块链-比特币">
          <a href="#什么是区块链-比特币" class="heading-link"><i class="fas fa-link"></i></a>什么是区块链/比特币</h2>
      <ol>
<li>比特币的底层网络实现</li>
<li>区块链的分类</li>
<li>区块链安全保障</li>
<li>利益共同体</li>
<li>钱包</li>
</ol>

        <h3 id="比特币的底层网络实现">
          <a href="#比特币的底层网络实现" class="heading-link"><i class="fas fa-link"></i></a>比特币的底层网络实现</h3>
      <ol>
<li>并不是虚拟货币比特币本质上是记账本</li>
<li>不可篡改</li>
<li>公开</li>
<li>安全</li>
<li>可变成</li>
<li>匿名</li>
<li>去中心</li>
</ol>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/author.png" alt="avatar"></div></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">34</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">10</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">15</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>zhen wu</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v4.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.0.0"></script><script src="/js/stun-boot.js?v=2.0.0"></script><script src="/js/scroll.js?v=2.0.0"></script><script src="/js/header.js?v=2.0.0"></script><script src="/js/sidebar.js?v=2.0.0"></script></body></html>