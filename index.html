<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/icon16.png?v=2.0.0" type="image/png" sizes="16x16"><link rel="icon" href="/assets/icon32.png?v=2.0.0" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="O ever youthful O ever weeping">
<meta property="og:url" content="www.lutongtian.club/index.html">
<meta property="og:site_name" content="O ever youthful O ever weeping">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhen wu">
<meta name="twitter:card" content="summary"><meta name="keywords" content="zhen wu, O ever youthful O ever weeping"><meta name="description" content=""><title>O ever youthful O ever weeping</title><link ref="canonical" href="www.lutongtian.club/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">O ever youthful O ever weeping</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/09/21/test/">test</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-21</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><img src="/21/test/09/21/test/image-20200921152436198.png" alt="test"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/08/25/Mysql%E9%94%81%E6%9C%BA%E5%88%B6/">Mysql锁机制</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-08-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-08-25</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Mysql-锁机制">
          <a href="#Mysql-锁机制" class="heading-link"><i class="fas fa-link"></i></a>Mysql 锁机制</h1>
      
        <h2 id="mysql锁的基本介绍">
          <a href="#mysql锁的基本介绍" class="heading-link"><i class="fas fa-link"></i></a>mysql锁的基本介绍</h2>
      <p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p>
<p>表级锁：开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
<p>行级锁：开销大，加锁满，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<p>从以上特点可见，表锁更适合进行表查询，只有少量按索引条件更新数据的应用，行锁更适合按索引条件并发更新少量不同数据，同时又有并发查询的应用。</p>

        <h2 id="MyISAM表锁">
          <a href="#MyISAM表锁" class="heading-link"><i class="fas fa-link"></i></a>MyISAM表锁</h2>
      <p>两种模式：表共享读锁和表独占写锁。</p>
<p>对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求，对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作，MyISAM表的读与写操作之间是串行的。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/08/10/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/">JVM运行时数据区</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-08-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-08-10</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="JAVA运行时数据区">
          <a href="#JAVA运行时数据区" class="heading-link"><i class="fas fa-link"></i></a>JAVA运行时数据区</h1>
      
        <h2 id="运行时数据区">
          <a href="#运行时数据区" class="heading-link"><i class="fas fa-link"></i></a>运行时数据区</h2>
      <p>PC：程序计数器，存放下一条指令位置</p>
<p>​    虚拟机的运行，类似这样的循环：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(not end)&#123;</span><br><span class="line">	取PC中的位置，找到对应位置的指令；</span><br><span class="line">	执行该指令；</span><br><span class="line">	PC++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>JVM stacks：栈帧</p>
<p>Direct Memory ： JVM可以直接访问的内核控件的内存（OS管理的内存）</p>
<p>​    NIO，提高效率，实现zero copy</p>
<p>Method Area：方法区，各种class，常量池</p>
<p>Heap：堆</p>

        <h2 id="线程共享区">
          <a href="#线程共享区" class="heading-link"><i class="fas fa-link"></i></a>线程共享区</h2>
      <p><img src="/10/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/D:%5Cstudy%5CMarkdown%5Cimages%5Cimage-20200708175434393.png" alt="image-20200708175434393"></p>
<p>每个线程都是自己的PC，多线程切换，记录执行到哪个指令了</p>

        <h2 id="栈帧">
          <a href="#栈帧" class="heading-link"><i class="fas fa-link"></i></a>栈帧</h2>
      <p>Frame</p>
<pre><code>1.    Local Variable Table ：局部变量表

   2.    Operand stack： 操作数栈
   3.    Dynamic Linking：指向常量池的指针
   4.    return address：返回值地址，a()调用了b(),b的返回值就存到这里</code></pre><p>一个方法对应一个栈帧，每个栈帧都记录了上面的4项。</p>

        <h2 id="常用指令">
          <a href="#常用指令" class="heading-link"><i class="fas fa-link"></i></a>常用指令</h2>
      <p>store： ()store_#xxx，等于压栈，把#xxx的数据读出来压栈，()内代表基本数据类型的缩写，比如int就是i。</p>
<p>load： ()load_#xxx，出栈，和store差不多</p>
<p>invoke</p>
<pre><code>1.    invokeStatic：调静态方法

   2.    invokeVirtual：多态的方法
   3.    invokeInterface：调接口方法
   4.    invokeSpecial：可以直接定位，不需要多态的方法,private和构造方法。
   5.    InvokeDynamic：</code></pre></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/08/08/JVM%E8%B0%83%E4%BC%98/">JVM调优</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-08-08</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-08-08</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="JVM调优">
          <a href="#JVM调优" class="heading-link"><i class="fas fa-link"></i></a>JVM调优</h1>
      
        <h2 id="调优命令">
          <a href="#调优命令" class="heading-link"><i class="fas fa-link"></i></a>调优命令</h2>
      <p>HotSpot参数分类</p>
<p>标准：-开头，所有的HotSpot都支持</p>
<p>非标准：-X开头，特定版本HotSpot支持特定命令</p>
<p>不稳定：-XX开头，下个版本可能取消</p>

        <h3 id="区分概念：内存泄漏memory-leak，内存溢出outofmemory">
          <a href="#区分概念：内存泄漏memory-leak，内存溢出outofmemory" class="heading-link"><i class="fas fa-link"></i></a>区分概念：内存泄漏memory leak，内存溢出outofmemory</h3>
      <ol>
<li><p>java -XX:+PrintCommandLineFlags xxx</p>
<p>查看当前的虚拟机命令</p>
</li>
<li><p>java -Xmn10M -Xms40M -Xmx60M -XX:+PrintGC xxx</p>
<p>Xmn设置新生代大小 Xms设置堆的最小值，Xmx设置最大值，最好最大值和最小值一样，不要让堆有弹性空间，因为增长和收缩堆大小会消耗大量的计算机资源。</p>
</li>
<li><p>java -XX:+UseConcMarkSweepGC xxx</p>
<p>设置使用CMS</p>
</li>
</ol>
<p>PS日志格式</p>
<p><img src="/08/JVM%E8%B0%83%E4%BC%98/D:%5Cstudy%5CMarkdown%5Cimages%5Cimage-20200709184641655.png" alt="image-20200709184641655"></p>

        <h2 id="heap-dump解读：">
          <a href="#heap-dump解读：" class="heading-link"><i class="fas fa-link"></i></a>heap dump解读：</h2>
      <p><img src="/08/JVM%E8%B0%83%E4%BC%98/D:%5Cstudy%5CMarkdown%5Cimages%5Cimage-20200709185617606.png" alt="image-20200709185617606"></p>

        <h2 id="调优的基础概念">
          <a href="#调优的基础概念" class="heading-link"><i class="fas fa-link"></i></a>调优的基础概念</h2>
      <p>吞吐量：用户代码时间 / (用户代码时间 + 垃圾回收时间)</p>
<p>响应时间；STW越短，响应时间越好</p>
<p>吞吐量优先的：PS + PO，数据挖掘</p>
<p>响应时间优先：G1，网站 API</p>

        <h3 id="什么是调优">
          <a href="#什么是调优" class="heading-link"><i class="fas fa-link"></i></a>什么是调优</h3>
      <ol>
<li>根据需求进行JVM规划和预调优</li>
<li>优化运行JVM运行环境</li>
<li>解决JVM运行过程中出现的各种问题（OOM）</li>
</ol>

        <h3 id="调优，从规划开始">
          <a href="#调优，从规划开始" class="heading-link"><i class="fas fa-link"></i></a>调优，从规划开始</h3>
      <p>调优，从业务场景开始</p>
<p>无监控，不调优，监控是压力测试</p>
<p>步骤：</p>
<ol>
<li><p>赎续业务场景（没有最好的垃圾回收器，只有最合适的垃圾回收器）</p>
<pre><code>  1.    响应时间、停顿时间【CMS G1 ZGC】
  2.    吞吐量

3.    选择回收器组合

4.    计算内存需求

5.    设定年达大小

6.    设定日志参数</code></pre><p>记录GC日志文件</p>
<p>-Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log </p>
<p>-XX:+UseGCLogFileRotation </p>
<p>-XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M</p>
<p> -XX:+PrintGCDetails -XX:+PrintGCDateStamps </p>
<p>-XX:+PrintGCCause</p>
<p>或者每天产生一个日志文件</p>
</li>
<li><p>观察日志情况</p>
</li>
</ol>

        <h2 id="解决JVM运行中的问题">
          <a href="#解决JVM运行中的问题" class="heading-link"><i class="fas fa-link"></i></a>解决JVM运行中的问题</h2>
      <ol>
<li><p>java -Xms200M -Xmx200M -XX:+PrintGC com.mashibing.jvm.gc.T15_FullGC_Problem01</p>
</li>
<li><p>一般是运维团队首先受到报警信息（CPU Memory）</p>
</li>
<li><p>top命令观察到问题：内存不断增长 CPU占用率居高不下</p>
</li>
<li><p>top -Hp 观察进程中的线程，哪个线程CPU和内存占比高</p>
</li>
<li><p>jps定位具体java进程 jstack 定位线程状况，重点关注：WAITING BLOCKED eg. waiting on &lt;0x0000000088ca3310&gt; (a java.lang.Object) 假如有一个进程中100个线程，很多线程都在waiting on ，一定要找到是哪个线程持有这把锁 怎么找？搜索jstack dump的信息，找 ，看哪个线程持有这把锁RUNNABLE 作业：1：写一个死锁程序，用jstack观察 2 ：写一个程序，一个线程持有锁不释放，其他线程等待</p>
</li>
<li><p>为什么阿里规范里规定，线程的名称（尤其是线程池）都要写有意义的名称 怎么样自定义线程池里的线程名称？（自定义ThreadFactory）</p>
</li>
<li><p>jinfo pid</p>
</li>
<li><p>jstat -gc 动态观察gc情况 / 阅读GC日志发现频繁GC / arthas观察 / jconsole/jvisualVM/ Jprofiler（最好用） jstat -gc 4655 500 : 每个500个毫秒打印GC的情况 </p>
</li>
<li><p>jmap - histo 4655 | head -20，查找有多少对象产生</p>
</li>
<li><p>jmap -dump:format=b,file=xxx pid ：</p>
<p>线上系统，内存特别大，jmap执行期间会对进程产生很大影响，甚至卡顿（电商不适合）</p>
<p> 1：设定了参数HeapDump，OOM的时候会自动产生堆转储文件 </p>
<p>2：很多服务器备份（高可用），停掉这台服务器对其他服务器不影响 </p>
<p>3：在线定位(一般小点儿公司用不到)</p>
</li>
<li><p>java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError com.mashibing.jvm.gc.T15_FullGC_Problem01</p>
</li>
<li><p>使用MAT / jhat /jvisualvm 进行dump文件分析 <span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html" target="_blank" rel="noopener">https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> jhat -J-mx512M xxx.dump <span class="exturl"><a class="exturl__link" href="http://192.168.17.11:7000/" target="_blank" rel="noopener">http://192.168.17.11:7000</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 拉到最后：找到对应链接 可以使用OQL查找特定问题对象</p>
</li>
<li><p>找到代码的问题</p>
</li>
</ol>

        <h4 id="arthas在线排查工具">
          <a href="#arthas在线排查工具" class="heading-link"><i class="fas fa-link"></i></a>arthas在线排查工具</h4>
      <ul>
<li>为什么需要在线排查？ 在生产上我们经常会碰到一些不好排查的问题，例如线程安全问题，用最简单的threaddump或者heapdump不好查到问题原因。为了排查这些问题，有时我们会临时加一些日志，比如在一些关键的函数里打印出入参，然后重新打包发布，如果打了日志还是没找到问题，继续加日志，重新打包发布。对于上线流程复杂而且审核比较严的公司，从改代码到上线需要层层的流转，会大大影响问题排查的进度。</li>
<li>jvm观察jvm信息</li>
<li>thread定位线程问题</li>
<li>dashboard 观察系统情况</li>
<li>heapdump + jhat分析</li>
<li>jad反编译 动态代理生成类的问题定位 第三方的类（观察代码） 版本问题（确定自己最新提交的版本是不是被使用）</li>
<li>redefine 热替换 目前有些限制条件：只能改方法实现（方法已经运行完成），不能改方法名， 不能改属性 m() -&gt; mm()</li>
<li>sc - search class</li>
<li>watch - watch method</li>
<li>没有包含的功能：jmap</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/08/05/JVM%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">JVM知识体系</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-08-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-08-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="JVM知识体系">
          <a href="#JVM知识体系" class="heading-link"><i class="fas fa-link"></i></a>JVM知识体系</h1>
      <p><img src="/05/JVM%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/D:%5Cstudy%5CMarkdown%5Cimages%5Cimage-20200707184416318.png" alt="image-20200707184416318"></p>

        <h2 id="类加载过程">
          <a href="#类加载过程" class="heading-link"><i class="fas fa-link"></i></a>类加载过程</h2>
      <p><img src="/05/JVM%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/D:%5Cstudy%5CMarkdown%5Cimages%5Cimage-20200707214902079.png" alt="image-20200707214902079"></p>
<ol>
<li>加载过程<ol>
<li>Loading：双亲委派</li>
<li>Linking<ol>
<li>Verification：校验，符合不符合class标准</li>
<li>Preparation：把class静态变量赋默认值</li>
<li>Resolution：Class常量值用的符号引用，转换成内存地址</li>
</ol>
</li>
<li>initializing：静态变量赋值为初始值。</li>
</ol>
</li>
</ol>

        <h3 id="类加载器">
          <a href="#类加载器" class="heading-link"><i class="fas fa-link"></i></a>类加载器</h3>
      <p><img src="/05/JVM%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/D:%5Cstudy%5CMarkdown%5Cimages%5Cimage-20200707215246317.png" alt="image-20200707215246317"></p>
<p>class漏到内存后，有两块内容，class内容放到内存，还有会生成一个class类对象，这个对象指向内存中的内容。</p>
<p>双亲委派机制：</p>
<p>​    如果有一个类A，需要漏到内存，会先从Custom加载器查询，如果没查询到，就委托给APP加载器，一直到Bootstrap，还没找到，就从Bootstrap加载器开始实际加载类A，如果Bootstrap发现类A不在自己加载的职责范围内，就委托给EXT加载器，一直到Custom加载器。</p>
<p>每个加载器都有自己的缓存，记录自己加载的类。</p>
<p>为什么要做双亲委派，不直接都漏到同一个内存？</p>
<p>​    主要是为了安全，比如自定义实现一个java.lang.String类，会覆盖掉原java的类库</p>

        <h2 id="自定义类加载器">
          <a href="#自定义类加载器" class="heading-link"><i class="fas fa-link"></i></a>自定义类加载器</h2>
      <p>使用ClassLoadr的loadClass方法，读取自己写的class。</p>
<p>继承ClassLoader类，重写findClass方法，把class文件转成二进制流，再调用defineClass，生成class对象</p>

        <h2 id="懒加载">
          <a href="#懒加载" class="heading-link"><i class="fas fa-link"></i></a>懒加载</h2>
      <p>JVM规范并没有规定什么时候加载类</p>
<p>但是严格规定了什么时候必须初始化</p>

        <h2 id="解释器">
          <a href="#解释器" class="heading-link"><i class="fas fa-link"></i></a>解释器</h2>
      <p><img src="/05/JVM%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/D:%5Cstudy%5CMarkdown%5Cimages%5Cimage-20200707231850298.png" alt="image-20200707231850298"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/08/01/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">JAVA内存模型</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-08-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-08-01</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="JAVA内存模型">
          <a href="#JAVA内存模型" class="heading-link"><i class="fas fa-link"></i></a>JAVA内存模型</h1>
      
        <h2 id="硬件层并发优化基础">
          <a href="#硬件层并发优化基础" class="heading-link"><i class="fas fa-link"></i></a>硬件层并发优化基础</h2>
      
        <h3 id="存储器的层次结构">
          <a href="#存储器的层次结构" class="heading-link"><i class="fas fa-link"></i></a>存储器的层次结构</h3>
      <p><img src="/01/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%5Cimages%5Cimage-20200707234920046.png" alt="image-20200707234920046"></p>

        <h3 id="cache-line-padding">
          <a href="#cache-line-padding" class="heading-link"><i class="fas fa-link"></i></a>cache line padding</h3>
      <p>利用MESI（缓存一致性协议），对齐cpu缓存头，不被其他数据干扰，提高效率，在变量前后增加 public long p1,p2,p3…..p7</p>
<p><img src="/01/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/D:%5Cstudy%5CMarkdown%5Cimages%5Cimage-20200708001829005.png" alt="image-20200708001829005"></p>

        <h2 id="CPU乱序">
          <a href="#CPU乱序" class="heading-link"><i class="fas fa-link"></i></a>CPU乱序</h2>
      <p>CPU为了提高执行执行效率，会在一条执行执行过程中，去同时执行另一条指令，前提是，两条指令没依赖关系。</p>
<p>如何保证不乱序：volatile</p>
<p>volatile:</p>
<pre><code>1.    有序性保障
         1.    intel lock ，汇编指令
2.    CPU内存屏障
         1.    sfence：存屏障，在sfence指令前的写操作必须在sfence写操作后的操作前完成。
         2.    lfence：读屏障，同sfence。
         3.    mfence：读写屏障，同sfence。</code></pre>
        <h2 id="volatile的实现细节">
          <a href="#volatile的实现细节" class="heading-link"><i class="fas fa-link"></i></a>volatile的实现细节</h2>
      <p>字节码层面：ACC_VOLATILE</p>
<p>JVM层面：volatile内存区的读写都加屏障</p>
<p>OS和硬件层面：lock 指令</p>

        <h2 id="synchronize的实现细节">
          <a href="#synchronize的实现细节" class="heading-link"><i class="fas fa-link"></i></a>synchronize的实现细节</h2>
      <p>字节码层面：加入monitorenter monitorexit  </p>
<p>JVM层面：C   C++调用了操作系统提供的同步机制</p>
<p>OS和硬件层面：lock 指令</p>

        <h2 id="java并发内存模型">
          <a href="#java并发内存模型" class="heading-link"><i class="fas fa-link"></i></a>java并发内存模型</h2>
      <p><img src="/01/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%5Cimages%5Cimage-20200708143902762.png" alt="image-20200708143902762"></p>

        <h2 id="对象的创建过程">
          <a href="#对象的创建过程" class="heading-link"><i class="fas fa-link"></i></a>对象的创建过程</h2>
      <ol>
<li>class loading</li>
<li>class linking（verif，prepar，resolu）</li>
<li>init   静态变量设初始值，同时执行静态语句块</li>
<li>申请对象内存</li>
<li>成员变量赋默认值</li>
<li>调用构造方法<ol>
<li>成员变量顺序赋初始值</li>
<li>执行构造方法语句</li>
</ol>
</li>
</ol>

        <h3 id="对象在内存中的布局">
          <a href="#对象在内存中的布局" class="heading-link"><i class="fas fa-link"></i></a>对象在内存中的布局</h3>
      <p>普通对象：</p>
<pre><code>1.    对象头：markword 8，标识一些对象的状态

   2.    ClassPointer指针：指向XX.class，为4字节，如果不开启jvm的UseCompreessedClassointers为8字节
   3.    实例数据：成员变量，引用类型，开启Oops为4字节，不开启为8字节
   4.    Padding对齐，8的倍数。</code></pre><p>数组对象：</p>
<p>​    比普通对象多个数组长度（4字节）</p>

        <h3 id="对象头具体包括什么">
          <a href="#对象头具体包括什么" class="heading-link"><i class="fas fa-link"></i></a>对象头具体包括什么</h3>
      <p>markword 8个字节 64位</p>
<p>有1位代表是不是偏向锁</p>
<p>有两位代表对象有没有被锁定（sync）</p>
<p>4位代表GC分代年龄</p>
<p>其他的是根据锁的不同，存储不同的东西。</p>

        <h3 id="对象定位">
          <a href="#对象定位" class="heading-link"><i class="fas fa-link"></i></a>对象定位</h3>
      <ol>
<li>句柄池</li>
<li>直接指针 ClassPointer</li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/08/01/JVM-GC%E8%B0%83%E4%BC%98/">JVM-GC调优</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-08-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-08-01</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="JVM-GC-Collector">
          <a href="#JVM-GC-Collector" class="heading-link"><i class="fas fa-link"></i></a>JVM-GC Collector</h1>
      
        <h2 id="垃圾">
          <a href="#垃圾" class="heading-link"><i class="fas fa-link"></i></a>垃圾</h2>
      <p>没有引用指向的，都是垃圾。</p>

        <h3 id="java垃圾处理">
          <a href="#java垃圾处理" class="heading-link"><i class="fas fa-link"></i></a>java垃圾处理</h3>
      <p>GC处理垃圾</p>
<p>开发效率高，执行效率低</p>

        <h3 id="Root-Searching-根可达算法">
          <a href="#Root-Searching-根可达算法" class="heading-link"><i class="fas fa-link"></i></a>Root  Searching 根可达算法</h3>
      <p><img src="/01/JVM-GC%E8%B0%83%E4%BC%98/D:%5Cstudy%5CMarkdown%5Cimages%5Cimage-20200709122136643.png" alt="image-20200709122136643"></p>

        <h3 id="GC-Algorithms-引用计数">
          <a href="#GC-Algorithms-引用计数" class="heading-link"><i class="fas fa-link"></i></a>GC Algorithms 引用计数</h3>
      <p>Mark-Sweep（标记清除）：把没用的标记出来，清掉。</p>
<p>​        存活的对象比较多的情况下，效率比较高。</p>
<p>​        执行效率低，需要两遍扫描，容易产生碎片。</p>
<p>Copying（拷贝）：把内存一分为二，把没用的和有用的分开</p>
<p>​        适用于存活的对象较少的情况，只扫描一次，效率高，没有碎片。</p>
<p>​        空间浪费，移动复制对象，需要调整对象引用</p>
<p>​        适合eden区</p>
<p>Mark——Compact（标记压缩）：把存活对象整理到一个角落或者控件，剩下的全部清掉。</p>
<p>​        不会产生碎片，方便对象分配，不会产生内存减半。</p>
<p>​        扫描两次，需要移动对象，效率偏低。</p>

        <h2 id="JVM内存分代模型">
          <a href="#JVM内存分代模型" class="heading-link"><i class="fas fa-link"></i></a>JVM内存分代模型</h2>
      <p>部分垃圾回收期使用的模型</p>
<p>字符串常量自1.8后移动到堆里</p>
<p>Metaspce是堆之外的空间，受限于物理内存</p>

        <h3 id="新生代-老年代-元数据区Metaspace">
          <a href="#新生代-老年代-元数据区Metaspace" class="heading-link"><i class="fas fa-link"></i></a>新生代+老年代+元数据区Metaspace</h3>
      <p>新生代：Eden+2个suvivor区</p>
<pre><code>1.    YGC回收之后，大多数对象会被回收，活着的进入S0

   2.    再次YGC，活着的对象eden+s0 -&gt; s1
   3.    再次YGC,eden+ s1 -&gt; s0
   4.    年龄足够 --老年代（15，CMS 6）
   5.    s区装不下 --老年代</code></pre><p>老年代：顽固分子  ，老年代满了FGC</p>
<p>GC</p>

        <h2 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>
      <p><img src="/01/JVM-GC%E8%B0%83%E4%BC%98/D:%5Cstudy%5CMarkdown%5Cimages%5Cimage-20200709140252110.png" alt="image-20200709140252110"></p>
<h2 id><a href="#" class="headerlink" title></a></h2>
        <h2 id="垃圾回收器">
          <a href="#垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a>垃圾回收器</h2>
      <p><img src="/01/JVM-GC%E8%B0%83%E4%BC%98/D:%5Cstudy%5CMarkdown%5Cimages%5Cimage-20200709160805568.png" alt="image-20200709160805568"></p>
<ol>
<li><p>Serial：stop-the-world，停止所有线程，但是要在save point（安全点）进行停止，进行垃圾回收，单CPU效率最高，适合内存小的时候用。</p>
</li>
<li><p>Parallel Scavenge：默认JVM使用的就是PS+PO，区别和Serial就是并行</p>
</li>
<li><p>Parallel old：老年代使用的，是用Compact垃圾回收算法。</p>
</li>
<li><p>ParNew：是Parallel的变种，做了支持CMS的增强</p>
</li>
<li><p>CMS：<img src="/01/JVM-GC%E8%B0%83%E4%BC%98/D:%5Cstudy%5CMarkdown%5Cimages%5Cimage-20200709163326430.png" alt="image-20200709163326430"></p>
<p>分为4个阶段</p>
<p>初始标记：是标记根对象，其他的先不标记</p>
<p>并发标记：是同时允许程序运行，并启动多线程同时进行标记，主要是这部分占用时间长</p>
<p>重新标记：是把并发标记中过程中，诞生出的新的垃圾，做重新标记，这块就是STW了。</p>
<p>并发清理：进行并发清理。</p>
<p>CMS的缺点：会产生内存碎片，当多次CMS后，新生代往老年代移动的时候，如果发现老年代里都是碎片，没地了。就会触发单线程的Serial，进行清理，速度非常慢</p>
<p>解决方案：</p>
<pre><code>1.    调整CMS发生FGC的内存阈值，默认是92%，改成50-80%。看情况。</code></pre></li>
</ol>

        <h4 id="垃圾收集器跟内存大小的关系">
          <a href="#垃圾收集器跟内存大小的关系" class="heading-link"><i class="fas fa-link"></i></a>垃圾收集器跟内存大小的关系</h4>
      <p>serial  几十兆</p>
<p>PS 上百兆-几G</p>
<p>CMS-20G</p>
<p>G1-上百G</p>
<p>ZGC- 4T - 16T</p>

        <h2 id="并发阶段的算法">
          <a href="#并发阶段的算法" class="heading-link"><i class="fas fa-link"></i></a>并发阶段的算法</h2>
      
        <h3 id="三色标记算法-CMS-incrementtal-Update">
          <a href="#三色标记算法-CMS-incrementtal-Update" class="heading-link"><i class="fas fa-link"></i></a>三色标记算法-CMS + incrementtal Update</h3>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/07/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%8E%9F%E7%90%86/">区块链-原理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-07-29</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-07-29</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="区块链-比特币、挖矿、抄币的原理">
          <a href="#区块链-比特币、挖矿、抄币的原理" class="heading-link"><i class="fas fa-link"></i></a>区块链-比特币、挖矿、抄币的原理</h1>
      <p>去中心化的、匿名的、安全的、不可篡改的、开放的下一代互联网</p>

        <h2 id="区块链中的三权分立">
          <a href="#区块链中的三权分立" class="heading-link"><i class="fas fa-link"></i></a>区块链中的三权分立</h2>
      <ol>
<li>币圈</li>
<li>链圈</li>
<li>矿圈</li>
</ol>

        <h2 id="什么是区块链-比特币">
          <a href="#什么是区块链-比特币" class="heading-link"><i class="fas fa-link"></i></a>什么是区块链/比特币</h2>
      <ol>
<li>比特币的底层网络实现</li>
<li>区块链的分类</li>
<li>区块链安全保障</li>
<li>利益共同体</li>
<li>钱包</li>
</ol>

        <h3 id="比特币的底层网络实现">
          <a href="#比特币的底层网络实现" class="heading-link"><i class="fas fa-link"></i></a>比特币的底层网络实现</h3>
      <ol>
<li>并不是虚拟货币比特币本质上是记账本</li>
<li>不可篡改</li>
<li>公开</li>
<li>安全</li>
<li>可变成</li>
<li>匿名</li>
<li>去中心</li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/07/03/Mysql%E7%B4%A2%E5%BC%95/">Mysql索引</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-07-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-07-03</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Mysql索引数据结构">
          <a href="#Mysql索引数据结构" class="heading-link"><i class="fas fa-link"></i></a>Mysql索引数据结构</h1>
      
        <h2 id="哈希表作为索引">
          <a href="#哈希表作为索引" class="heading-link"><i class="fas fa-link"></i></a>哈希表作为索引</h2>
      <p>哈希表可以完成索引的存储，每次在添加索引的时候需要计算指定列的hash值，取模运算后计算出下标，将元素插入下标位置即可。</p>
<p>适合场景：</p>
<p>​    等值查询</p>
<p>​    表中的数据是无序数据（范围查找的时候比较浪费时间，需要挨个进行遍历操作）</p>
<p>​    在实际应用中，范围查询使用比较多，所以此时hash表不是特别合适</p>
<p>​    且hash表再使用的时候，需要将全部的数据加载到内存，比较耗费内存的空间，也不是很合适。</p>

        <h2 id="树">
          <a href="#树" class="heading-link"><i class="fas fa-link"></i></a>树</h2>
      <p>目前树有的结构：多叉树、二叉树、avl树、红黑树。</p>
<p>多叉树（B树）：在树的结构中，左子树必须小于根节点，右子树必须大于根节点，从左到右必须有序。</p>
<p>二叉树：二分查找树，比多叉树效率高，但很容易出现单方向子节点连续增加，变成链表。</p>
<p>avl平衡树：要求左右子树必须严格一致，最高子树和最低子树高度差不超过1，若超过1，树就要进行旋转，数据量大时，树会频繁进行旋转，影响性能。</p>
<p>红黑树：基于AVL树的升级，损失部分查询性能，来提升插入的性能，在红黑树种最低子树和最高子树高度差小于2倍即可。在插入的时候不需要进行N多次的旋转，而且还加入了变色的特性，来满足插入和查询性能的平衡。</p>
<p>以上二叉树的变种都不适合作为mysql的索引</p>
<p>​    一：树的深度无法控制，哪怕是红黑树，在最低深度为8时，也可能会进行16次的查询，严重影响性能。</p>
<p>​    二：在插入数据这方面的性能都比较低。</p>
<p>目前来看，B树是作为索引的最佳数据结构。</p>
<p>B树的特点：</p>
<p>​    1.所有的键值分布在整颗树种；</p>
<p>​    2.搜索有可能在非叶子节点结束，在关键字全集内做一次查找，性能逼近二分查找；</p>
<p>​    3.每个节点最多有m个子树；</p>
<p>​    4.根节点至少有2个子树；</p>
<p>​    5.分支节点至少拥有m/2个子树（除根节点和叶子节点之外都是分支节点）；</p>
<p>​    6.所有叶子节点都在同一层，每个节点最多有m-1个key，并且升序排列；</p>
<p>缺点：</p>
<p>​    每个节点都有key值，同时也包含data，而每个页存储空间有限，如果data比较大会导致每个节点存储的key数量变小。</p>
<p>​    当存储的数据量很大时，会导致树的深度较大，增大查询时磁盘IO次数，影响查询性能。</p>
<p>B+树：</p>
<p>​    1.每个节点可以包含更多的节点，这样做有两个原因，一个是树的高度降低，第二个原因是数据范围变成多个区间，区间越多，数据检索越快。</p>
<p>​    2.非叶子节点存储key，叶子节点存储key和数据。</p>
<p>​    3.叶子节点两两指针互相连接，顺序查询性能更高。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/26/Mysql%E7%BB%84%E4%BB%B6/">Mysql组件</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-06-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-06-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Mysql架构">
          <a href="#Mysql架构" class="heading-link"><i class="fas fa-link"></i></a>Mysql架构</h1>
      
        <h2 id="连接器">
          <a href="#连接器" class="heading-link"><i class="fas fa-link"></i></a>连接器</h2>
      <p>负责和客户端建立连接，获取权限、维持和管理连接</p>
<p>​    -用户名密码验证</p>
<p>​    -查询权限信息，分配对应的权限</p>
<p>​    -可以使用processlist查看现在的连接</p>
<p>​    -如果太长时间没有动静，就会自动断开，通过wait——timeout控制，默认8小时。</p>
<p>连接可以分为两类：</p>
<p>​    -长连接：推荐使用，但是要周期性断开长连接。</p>
<p>​    -短连接</p>
<p>​    数据库连接池属于长连接，连接池中会一直保有一些长连接。</p>

        <h2 id="分析器">
          <a href="#分析器" class="heading-link"><i class="fas fa-link"></i></a>分析器</h2>
      <p>词法分析：mysql需要把输入的字符串进行识别每个部分代表什么意思。</p>
<p>​    -把字符串T识别成表名T</p>
<p>​    -把字符串ID识别成列ID</p>
<p>语法分析：</p>
<p>​    根据语法规则判断这个sql语句是否满足mysql的语法，如果不符合就会报错。</p>

        <h2 id="优化器">
          <a href="#优化器" class="heading-link"><i class="fas fa-link"></i></a>优化器</h2>
      <p>在具体执行SQL语句之前，要先经过优化器的处理。</p>
<p>​    -当表中有多个索引的时候，决定用哪个索引。</p>
<p>​    -当SQL语句需要多表关联的时候，决定表的连接顺序</p>
<p>不同的执行方式对SQL语句的执行效率影响很大。</p>
<p>​    -RBO:基于规则的优化</p>
<p>​    -CBO:基于成本的优化</p>
<p>一般使用CBO比较多，主要考虑性能问题的时候较多。</p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/author.png" alt="avatar"></div></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">30</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">8</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">13</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>zhen wu</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v4.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.0.0"></script><script src="/js/stun-boot.js?v=2.0.0"></script><script src="/js/scroll.js?v=2.0.0"></script><script src="/js/header.js?v=2.0.0"></script><script src="/js/sidebar.js?v=2.0.0"></script></body></html>